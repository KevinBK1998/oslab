[PROCESS_TABLE + [SYSTEM_STATUS_TABLE + 1] * 16 + 9] = INT_SEMGET;
alias userSP R0;
userSP = SP;
alias currentPID R1;
currentPID = [SYSTEM_STATUS_TABLE + 1];
[PROCESS_TABLE + currentPID*16 + 13] = SP;
SP = [PROCESS_TABLE + currentPID*16 + 11] * 512 -1;


alias systemCall R2;
alias semId R3;
systemCall = [([PTBR + 2 * (userSP - 5)/ 512] * 512) + ((userSP - 5) % 512)];
semId = [([PTBR + 2 * (userSP - 4)/ 512] * 512) + ((userSP - 4) % 512)];

if (systemCall == INT_SEMLOCK) then
    [PROCESS_TABLE + currentPID*16 + 9]=systemCall;
    alias userAreaPageNumber R4;
    userAreaPageNumber = [PROCESS_TABLE + currentPID*16 + 11];
    alias semTableIndex R5;
    semTableIndex = [userAreaPageNumber*512+RESOURCE_TABLE_OFFSET+semId*2+1];
    while ([SEMAPHORE_TABLE + semTableIndex*4]!=-1) do
        [PROCESS_TABLE+16*currentPID+4]=WAIT_SEMAPHORE;
        [PROCESS_TABLE+16*currentPID+4]=semTableIndex;
        multipush(R0,R1,R2,R3,R4,R5);
        call SCHEDULER;
        multipop(R0,R1,R2,R3,R4,R5);
    endwhile;
    [SEMAPHORE_TABLE + semTableIndex*4] = currentPID;
    endif;
    breakpoint;
else if (systemCall == INT_SEMUNLOCK) then
    [PROCESS_TABLE + currentPID*16 + 9]=systemCall;
    alias semTableIndex R4;
    semTableIndex = [userAreaPageNumber*512+RESOURCE_TABLE_OFFSET+semId*2+1];
    [SEMAPHORE_TABLE + semTableIndex*4]=-1;
    alias pid R5;
    pid=1;
    while(pid < 16) do
        alias process_table_entry R6;
        process_table_entry=PROCESS_TABLE + 16 * pid;
        if ([process_table_entry + 4] == WAIT_SEMAPHORE && [process_table_entry + 5] == semIndex && [process_table_entry + 1]!=-1) then
            [process_table_entry + 4] = READY;
        endif;
        pid = pid + 1;
    endwhile;
    breakpoint;
endif;
endif;

SP = userSP;
[PROCESS_TABLE + ( currentPID * 16) + 9] = 0;
ireturn;
